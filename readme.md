##Voronoi WebGL
#### Find this online: http://ifjorissen.github.io/webgl_voronoi/
#### GitHub Project Link (src): https://github.com/ifjorissen/webgl_voronoi/

###What this is:
A webgl visualization of a voronoi diagram as it is generated by Fortune's algorithm. (Kind of)

###Code:
The structure of this code is loosely based off of two books on Javascript from the series You Don't Know Javascript. The primiary influence comes from the book This & Object Prototypes, which eschews object (or class/inheritance-based design patterns) in favor of a pattern referred to as Objects Linked to Other Objects (OLOO). OLOO emphasizes behavior delegation and illustrates how a sort of object heirarchy can be created without using "pseudo"-classes or object prototypes. I've used a few anonymous functions as well, for good measure.  In my mind, this project was/is as much an exercise in webgl programming as it was/is an opportunity to learn a little bit about javascript and some common design patterns (and how *not* to do some things).  

In this project specifically, the main file is index.js. This file adds the buttons for the simulation and creates a webgl object from the WebGl function in webgl_render.js. Webgl_render.js is where the bulk of the rendering work is done. The webgl function returns initializes the shaders and creates the canvas context. It returns an object with the functions `scan()`, `tick()`, `addPoint()` and `reset()` among a few others. 

Perhaps most importantly are the files voronoi.js and binary_search_tree.js.  Voronoi.js contains the description of an anonymous function (called voronoi), which returns a Voronoi Object. This voronoi object manages all of the data of the voronoi diagram. It also has various `toBuffer` functions that the WebGl object managing the voronoi object can access and use to populate its buffers and draw the diagram. The voronoi object maintains a `scanline` which consists of two endpoints and a movement vector. When a user clicks the canvas, a point gets added to the visual diagram, and a Site object is created and stored in the voronoi object. The Site objects are sorted in a (pseudo) priority queue which orders them based on their distance from the scanline. When a 

The voronoi object also maintains the beachline using a (loose variant) of a binary search tree where the internal nodes store the breakpoints the arcs. This is the part of the project that needs the most work.



###What still needs to get done (& known bugs)
  * The binary tree that stores the beach line needs to be refined and looked at. 
  * Edges need to be defined and managed with a doubly-linked list. 
  * Circle events need to be defined, updated, and integrated into the priority queue.


###Tech:
This project uses browserify to `require()` modules & files and then bundle them up into one .js file (bundle.js). A beefy script (see beefy.js, run with the command `node beefy.js`) runs everything locally.  In an ideal world, the tests folders would be full of tests run by mocha/chai, but I didn't get around to that. 



####To run locally:
`npm install`
`node beefy.js`

(If the changes made in index.js aren't being reflected in the browser, make sure the script in index.html is scripts/index.js)

To make a new bundle file:
`browserify scripts/index.js>bundle.js -t brfs`

point your browser to localhost:9966

